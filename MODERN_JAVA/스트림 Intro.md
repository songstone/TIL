# 스트림 Intro

- 스트림은 소스에서 추출된 연속요소
- 데이터 처리 연산, 내부 반복 지원
- 병렬성 활용 가능
- **데이터 소스에 적용하는 데이터베이스 질의 느낌**
- 내부연산은 filter, map, sorted 등의 연산으로 반복을 추상화
- 중간연산
	- filter, map 과 같은 연산으로 스트림을 반환하면서 다른 연산과 연결
	- 연산을 이용해 파이프라인 구성가능
	- 최종 연산 전까지 중간 연산만으로는 결과를 알 수 없다.
- 최종연산
	- foreach, count 와 같은 연산으로 스트림 파이프라인을 처리해 결과 반환
- 스트림의 요소는 요청시 **_LAZY_** 하게 계산 된다.

## 스트림
- 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소
- 연속된 요소 : 스트림의 주제는 계산(컬렉션의 주제는 데이터)
- 소스 : 스트림은 컬렉션, 배열 I/O 자원 등의 데이터 제공소스로부터 데이터를 소비, 같은 순서 보장
- 데이터 처리 연산 : 순차적, 병렬적 실행 가능
- 파이프라이닝 : 대부부의 스트림 연산은 스트림 반환 -> 연결하여 큰 파이프라인 구성 가능, Laziness, Short-circuit 등의 최적화
```java
List<String> threeHighCaloricDishNames = menu.stream()
											.filter(dish -> dish.getCalories() > 300) // 특정요소만 추출 
											.map(Dish::getName) // 형태 변환
											.limit(3) // 정해진 개수만 추출
											.collect(Collectors.toList()); // 스트림을 컬렉션으로 변환하여 반환(최종연산)
```

## 스트림과 컬렉션
- 컬렉션은 현재 자료구조가 포함하는 모든 값을 메모리에 저장. 즉 컬렉션에 추가하기 전에 계산 해야만 한다.
- 스트림은 이론적으로 요청할 때만 요소를 계산하는 고정된 자료구조 -> 생성된 스트림에 요소를 추가하거나 제거 할수 없다.
- 스트림은 단 한번만 사용할 수 있다. 재사용이 필요하면 재생성
- 데이터 반복 처리 방법
	- 외부 반복(컬렉션)
	```java
	List<String> names = new ArrayList<>();
	for(Dish dish : menu) { // 컬렉션의 각 요소를 명시적으로 순차 반복
		names.add(dish.getName());
	}
	```
	- 내부 반복(스트림)
	```java
	List<String> names = menu.stream() // 스트림 내부에서 반복
							.map(Dish::getName)
							.collect(Collectors.toList());
	```
- 스트림은 내부적으로 반복을 처리하여 투명하게 병렬로 처리하거나 최적화하여 다양한 순서로 처리 가능하게 한다.

## 중간연산과 최종연산
- 중간연산
	- 다른 스트림 반환 -> 여러 중간 연산을 엮어 질의 생성 가능
	- 최종 연산을 스트림 파이프라인에 실행하기 전까지는 아무 연산도 실행하지 않는다 -> LAZY
- 최종연산
	- 스트림 파이프라인에서 결과를 도출
	- List, Integer, void 등 반환